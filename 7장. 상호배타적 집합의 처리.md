7장. 상호배타적 집합의 처리



#### -목표

연결리스트를 이용한 상호배타적 집합 처리 방법

트리를 이용한 상호배타적 집합 처리 방법



*배타적. 같은 값이 없는 것



#### -집합의 처리

상호배타적 집합만 그러면 교집합은 없음.

•지원할 연산

–Make-Set(*x*): 원소 *x*로만 이루어진 집합을 만든다

–Find-Set(*x*): 원소 *x*를 가지고 있는 집합을 알아낸다

–Union(*x*, *y*): 원소 *x*를 가진 집합과 원소 *y*를 가진 집합의 합집합



##### 연결리스트

같은 집합의 원소들은 하나의 연결리스트로 관리

연결리스트의 맨 앞의 원소를 집합의 대표원소로 삼기

![image-20221031140721191](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\image-20221031140721191.png)

하나의 원소로 이루어진 집합

![image-20221031140819919](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\image-20221031140819919.png)

연결리스트로 된 두집합

*포인터=주소값

무게를 고려한 합집합

두 집합을 합칠 때 작은 집합을 큰 집합 뒤에 붙인다.

대표원소를 가리키는 포인터 갱신 작업을 최소화하기 위한 것이다.

![image-20221031141231806](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\image-20221031141231806.png)

설명 abc연결리스트가 작은 집합이라서 뒤에 붙임.



ex) 제대 컴공에 재학중인 남학생 찾기.

if 컴퓨터공학~ ,if 남학생중에서~(어떤게 더 한번에 무게를 줄이는지 고려)

[정리 1]

연결 리스트를 이용해 표현되는 배타적 집합에서 **무게를 고려한** **Union**을 사용할 때, *m*번의 Make-Set, Union, Find-Set 중 *n*번이 Make-Set이라면 이들의 총 수행시간은 *O*(*m + n* log *n*)이다. 



##### 트리



같은 집합의 원소들은 하나의 트리로 관리한다.

​	자식도느가 부모노르를 가르킨다.

트리의 루트를 집합의 대표 원소로 삼는다.

![image-20221031142526318](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\image-20221031142526318.png)

*union에서 똑같은데 find에서 달라짐

![image-20221031142733170](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\image-20221031142733170.png)

c를 대표노드를 안삼고 e를 대표 노드로 삼는다면

합집합에서 연산이 같은데 find연산이 복잡해지고 길어짐.



Make-Set(*x*)  ▷ 노드 *x*를 유일한 원소로 하는 집합을 만든다.

{ 

​    *p*[*x*] ← *x* ; 

} 



Union(*x*, *y*)  ▷ 노드 *x*가 속한 집합과 노드 *y*가 속한 집합을 합친다 

{ 

​    *p*[Find-Set(*y*)] ← Find-Set(*x*) ; 

} 



Find-Set(*x*)  ▷ 노드 *x*가 속한 집합을 알아낸다. 

​    노드 *x*가 속한 트리의 루트 노드를 리턴한다. 

{ 

​    **if** (*x* = *p*[*x*]) 

 **then return** *x* ; 

 **else return** Find-Set(*p*[*x*]) ; 

} 



연산의 효율을 높이는 방법

•랭크를 이용한 Union

–각 노드는 자신을 루트로 하는 서브트리의 높이를 랭크Rank라는 이름으로 저장한다

–두 집합을 합칠 때 랭크가 낮은 집합을 랭크가 높은 집합에 붙인다

•경로압축

–Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 루트를 가리키도록 포인터를 바꾸어 준다